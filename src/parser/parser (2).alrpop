use super::ast::*;
use std::str::FromStr;

grammar;

pub Statment: Statment = {
    // Expr => Statment::Expr(<>),
    Bind => Statment::Bind(<>)
}

pub Expr: Expr = {
    Literal => Expr::Literal(<>),
    Identifier => Expr::Identifier(<>),
    Builtin => Expr::Builtin(<>),
    "[" <Exprs> "]" => Expr::List(<>),
    "(" <Exprs> ")" => Expr::Tuple(<>),
    Lambda => <>
}

Exprs: Vec<Expr> = {
    <mut v:(<Expr> ",")*> <e:Expr?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

pub Bind: Bind = {
    <n:Identifier> <v:Pattern*> "=" <e:Expr> => if !v.is_empty() {
        Bind(n, Expr::Lambda(v, Box::new(e)))
    } else {
        Bind(n, *Box::new(e))
    }
}

pub PCIdentifier: Identifier = {
    <r"[A-Z][a-zA-Z0-9]*"> => Identifier(<>.to_owned())
}

pub Identifier: Identifier = {
    <r"[a-z][a-zA-Z0-9]*"> => Identifier(<>.to_owned())
}

pub Builtin: Builtin = {
    "+" => Builtin::Plus,
    "-" => Builtin::Minus,
    "/" => Builtin::Div,
    "%" => Builtin::Mod,
    "^" => Builtin::Exp,
    "<" => Builtin::LT,
    ">" => Builtin::GT,
    ">=" => Builtin::GE,
    "<=" => Builtin::LE,
    "==" => Builtin::Eq,
    "/=" => Builtin::Ineq,
    "&&" => Builtin::And,
    "||" => Builtin::Or,
    "|" => Builtin::Pipe,
    ":" => Builtin::Colon
}

pub Literal: Literal = {
    <r"[+-]?\d+\.\d+"> => Literal::Float(f64::from_str(<>).expect("Expected floating point number")),
    <r"[+-]?\d+"> => Literal::Integer(<>.parse::<i64>().expect("Expected an integer")),
    <r#"".*""#> => Literal::String(<>[1..(<>.len()-1)].to_owned()),
    <r"'.'"> => Literal::Char(<>[1..(<>.len()-1)].chars().next().expect("Expected a character")), // r"'[^']*'"
    "True" => Literal::Bool(Bool::True),
    "False" => Literal::Bool(Bool::False)
}

pub Variant: Variant = {
    <n:PCIdentifier> <v:Types*> => Variant(n, v)
}

pub Types: Types = {
    #[precedence(level = "0")]
    <c:PCIdentifier> "(" <v:Types*> ")" => Types::App(Box::new(Types::Id(c)), v),

    #[precedence(level = "1")]
    PCIdentifier => Types::Id(<>),

    #[precedence(level = "2")]
    Identifier => Types::Generic(<>)
}

Pattern: Pattern = {
    "(" <p1:PatternApp> ":" <p2:PatternApp> ")" => Pattern::ListCons(Box::new(p1), Box::new(p2)),
    PatternApp
}

PatternApp: Pattern = {
    <i:PCIdentifier> <v:("(" PatternSimple* ")")?> => {
        let v = v.map(|x| x.1).unwrap_or(Vec::new());
        if !v.is_empty() {
            Pattern::App(Box::new(Pattern::Id(i)), v)
        } else {
            Pattern::Id(i)
        }
    },
    PatternSimple
}

PatternSimple: Pattern = {
    Identifier => Pattern::Variable(<>),
    Literal => Pattern::Literal(<>)
}

pub Lambda: Expr = {
    "\\" <v:Pattern*> "->" <e:Expr> => Expr::Lambda(v, Box::new(e))
}

pub Program: Vec<Statment> = Statment*;
